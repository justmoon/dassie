export const privateKeyLabelRegex =
  /-{5}BEGIN PRIVATE KEY-{5}\n([\d\n+/A-Za-z]+?)\n-{5}END PRIVATE KEY-{5}/

export const derPreamble = Buffer.from(
  "302E020100300506032B657004220420",
  "hex"
)

const PEM_KEY_HEADER = "-----BEGIN PRIVATE KEY-----\n"
const PEM_KEY_FOOTER = "\n-----END PRIVATE KEY-----"

/**
 * Parse a PEM-encoded Ed25519 private key.
 *
 * Handles keys generated by OpenSSL. Does not support encrypted private keys.
 *
 * @param source - The textual representation of a PEM file
 * @returns The raw Ed25519 private key
 * @see https://datatracker.ietf.org/doc/html/rfc7468#section-10
 */
export function parseEd25519PrivateKey(source: string): Buffer {
  if (source.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
    throw new Error("Parsing of encrypted private keys is not supported")
  }

  const match = privateKeyLabelRegex.exec(source) as [string, string] | null

  if (!match) {
    throw new Error("No ed25519 private key found in PEM file")
  }

  const derEncoding = Buffer.from(match[1].replaceAll("\n", ""), "base64")

  if (derEncoding.length !== 48) {
    throw new Error("Invalid length for DER-encoded ed25519 private key")
  }

  if (!derPreamble.equals(derEncoding.subarray(0, derPreamble.length))) {
    throw new Error("Unexpected data in DER-encoded ed25519 private key")
  }

  return derEncoding.subarray(derPreamble.length)
}

/**
 * Serialize a PEM-encoded Ed25519 private key.
 *
 * @param rawDassieKeyBuffer - The 32-byte raw Ed25519 private key
 * @returns The PEM-encoded private key
 */
export const serializeEd25519PrivateKey = (
  rawDassieKeyBuffer: Buffer
): string => {
  const dassieKeyBuffer = Buffer.concat([derPreamble, rawDassieKeyBuffer])
  const base64Key = dassieKeyBuffer.toString("base64")

  // Split the base64 into chunks of 64 characters per line for PEM formatting
  const base64Chunks = base64Key.match(/.{1,64}/g) ?? []
  const body = base64Chunks.join("\n")

  return PEM_KEY_HEADER + body + PEM_KEY_FOOTER
}
