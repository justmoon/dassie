import { resolve } from "node:path"

import { type Reactor, createComputed } from "@dassie/lib-reactive"
import { type DatabaseSchema, createDatabase } from "@dassie/lib-sqlite"

import { environmentConfigSignal } from "../config/environment-config"
import { CONFIG_DATABASE_SCALARS } from "../config/schemas/database-scalars"
import migrations from "./migrations"
import { incomingPaymentTable } from "./tables/incoming-payment"

/**
 * Unique application ID for identifying the SQLite database as belonging to Dassie.
 *
 * This constant application ID was generated by first generating a random, positive, signed, 32-bit integer
 * and replacing the second through fourth nibbles with the HEX digits "DA5" to represent Dassie.
 */
const DASSIE_SQLITE_APPLICATION_ID = 0x1d_a5_3b_81

export const DASSIE_DATABASE_SCHEMA = {
  applicationId: DASSIE_SQLITE_APPLICATION_ID,
  migrations,
  tables: {
    incomingPayment: incomingPaymentTable,
  },
  scalars: {
    ...CONFIG_DATABASE_SCALARS,
  },
} as const satisfies DatabaseSchema

export const betterSqliteNativeBindingComputed = () =>
  createComputed((sig) => {
    const { rootPath } = sig.use(environmentConfigSignal).read()

    return import.meta.env.PROD
      ? resolve(rootPath, "lib/better_sqlite3.node")
      : undefined
  })

export const databasePlain = (reactor: Reactor) => {
  const { dataPath } = reactor.use(environmentConfigSignal).read()
  const nativeBinding = reactor.use(betterSqliteNativeBindingComputed).read()

  const database = createDatabase({
    path: `${dataPath}/dassie.sqlite3`,
    schema: DASSIE_DATABASE_SCHEMA,
    nativeBinding,
  })

  reactor.onCleanup(() => {
    database.raw.close()
  })

  return database
}
