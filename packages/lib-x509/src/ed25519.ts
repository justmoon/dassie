import {
  areUint8ArraysEqual,
  concatUint8Arrays,
  hexToUint8Array,
} from "uint8array-extras"

import { parsePem, serializePem } from "./pem"

type KeyType = "private" | "public"

const PREAMBLE: Record<KeyType, Uint8Array> = {
  private: hexToUint8Array("302E020100300506032B657004220420"),
  public: hexToUint8Array("302A300506032B65700321"),
}

const EXPECTED_LENGTH: Record<KeyType, number> = {
  private: 48,
  public: 44,
}

const PEM_TAG: Record<KeyType, string> = {
  private: "PRIVATE KEY",
  public: "PUBLIC KEY",
}

/**
 * Parse a PEM-encoded Ed25519 private key.
 *
 * Handles keys generated by OpenSSL. Does not support encrypted private keys.
 *
 * @param source - The textual representation of a PEM file
 * @returns The raw Ed25519 private key
 * @see https://datatracker.ietf.org/doc/html/rfc7468#section-10
 */
export function parseEd25519Key(source: string, type: KeyType): Uint8Array {
  if (source.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
    throw new Error("Parsing of encrypted private keys is not supported")
  }

  const { data, tag } = parsePem(source)

  if (tag !== PEM_TAG[type]) {
    throw new Error(`No ed25519 ${type} key found in PEM file`)
  }

  if (data.length !== EXPECTED_LENGTH[type]) {
    throw new Error(`Invalid length for DER-encoded ed25519 ${type} key`)
  }

  if (
    !areUint8ArraysEqual(
      PREAMBLE[type],
      data.subarray(0, PREAMBLE[type].length),
    )
  ) {
    throw new Error(`Unexpected data in DER-encoded ed25519 ${type} key`)
  }

  return data.subarray(PREAMBLE[type].length)
}

/**
 * Serialize a PEM-encoded Ed25519 private key.
 *
 * @param rawDassieKeyBuffer - The 32-byte raw Ed25519 private key
 * @returns The PEM-encoded private key
 */
export const serializeEd25519Key = (key: Uint8Array, type: KeyType): string => {
  const data = concatUint8Arrays([PREAMBLE[type], key])

  return serializePem(data, PEM_TAG[type])
}
