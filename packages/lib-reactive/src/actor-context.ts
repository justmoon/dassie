import { Promisable } from "type-fest"

import { isObject } from "@dassie/lib-type-utils"

import { FactoryNameSymbol } from "."
import { type Actor, type RunOptions } from "./actor"
import { Listener } from "./internal/emit-to-listener"
import {
  ReactiveSelector,
  type ReactiveSource,
  defaultComparator,
} from "./internal/reactive"
import { DisposableLifecycleScopeImplementation } from "./lifecycle"
import { Mapped } from "./mapped"
import type { Factory, Reactor, UseOptions } from "./reactor"
import type { ReadonlyTopic } from "./topic"

export const defaultSelector = <T>(value: T) => value

export class ActorContext extends DisposableLifecycleScopeImplementation {
  constructor(
    /**
     * Name of the actor.
     *
     * @remarks
     *
     * This is automatically derived from the function name.
     */
    name: string,

    /**
     * Full path of the actor.
     *
     * @remarks
     *
     * The actor path is generated by concatenating the name of the actor with the names of all parent actors.
     */
    readonly path: string,

    /**
     * A reference to the current reactor.
     *
     * @remarks
     *
     * If you want to pass something to an external component to allow that component to interact with the reactive system, you can use this reference.
     */
    readonly reactor: Reactor,

    /**
     * Wake function. If called, the actor will be cleaned up and re-run.
     */
    readonly wake: () => void,

    /**
     * A function which allows tracked reads of signals.
     */
    private readonly _get: <TState>(signal: ReactiveSource<TState>) => TState,
  ) {
    super(name)
  }

  /**
   * Read the current value from a signal and automatically re-run the actor if the value changes.
   *
   * @remarks
   *
   * The way this works is that the {@link wake} function is registered as a listener on the signal. This will cause the actor to be re-run when the signal changes.
   *
   * To read a value without tracking, use {@link use} to get a reference and call `read()` on it.
   *
   * @param signalFactory - Reference to the signal's factory function.
   * @param selector - Used to select only part of the value from a given signal. This can be useful to avoid re-running the actor if only an irrelevant portion of the value has changed.
   * @param comparator - By default, the reactor checks for strict equality (`===`) to determine if the value has changed. This can be overridden by passing a custom comparator function.
   * @returns The current value of the signal, narrowed by the selector.
   */
  get<TState>(
    signalFactory: Factory<ReactiveSource<TState>> | ReactiveSource<TState>,
  ): TState
  get<TState, TSelection>(
    signalFactory: Factory<ReactiveSource<TState>> | ReactiveSource<TState>,
    selector: (state: TState) => TSelection,
    comparator?: (oldValue: TSelection, newValue: TSelection) => boolean,
  ): TSelection
  get<TState, TSelection>(
    signalFactory: Factory<ReactiveSource<TState>> | ReactiveSource<TState>,
    // Based on the overloaded function signature, the selector parameter may be omitted iff TMessage equals TSelection.
    // Therefore this cast is safe.
    selector: (state: TState) => TSelection = defaultSelector as unknown as (
      state: TState,
    ) => TSelection,
    comparator: (a: TSelection, b: TSelection) => boolean = defaultComparator,
  ) {
    const signal =
      typeof signalFactory === "function"
        ? this.use(signalFactory)
        : signalFactory

    if (selector === defaultSelector && comparator === defaultComparator) {
      return this._get(signal)
    } else {
      const intermediateSignal = new ReactiveSelector(
        signal,
        selector,
        comparator,
      )
      return this._get(intermediateSignal)
    }
  }

  /**
   * Convenience method for extracting specific keys from a signal.
   *
   * @remarks
   *
   * This method works like {@link get} but will automatically create the correct selector and comparator for the given keys. The actor will be re-run if any of the values for any of the keys change by strict equality.
   *
   * @param signal - Reference to the signal that should be queried.
   * @param keys - Tuple of keys that should be extracted from the signal.
   * @returns A filtered version of the signal state containing only the requested keys.
   */
  getKeys<TState, TKeys extends keyof TState>(
    signal: Factory<ReactiveSource<TState>> | ReactiveSource<TState>,
    keys: readonly TKeys[],
  ): Pick<TState, TKeys> {
    return this.get(
      signal,
      (state) => {
        const result = {} as Pick<TState, TKeys>
        for (const key of keys) {
          result[key] = state[key]
        }
        return result
      },
      (a, b) => {
        for (const key of keys) {
          if (a[key] !== b[key]) {
            return false
          }
        }
        return true
      },
    )
  }

  /**
   * Re-run this actor if a message is emitted on the given topic.
   *
   * @remarks
   *
   * Note that the actor will not necessarily re-run once per event. If multiple events are emitted on the topic before the actor has re-run, it will only re-run once.
   *
   * @param topic - Reference to the topic's factory function.
   */
  subscribe<TMessage>(
    topicFactory: Factory<ReadonlyTopic<TMessage>> | ReadonlyTopic<TMessage>,
  ) {
    this.once(topicFactory, this.wake)
  }

  /**
   * Like {@link ReadonlyTopic.on} but will automatically manage disposing the subscription when the current actor is disposed.
   *
   * @param topic - Reference to the topic, i.e. the message factory function.
   * @param listener - A function that will be called every time a message is emitted on the topic.
   */
  on<TMessage>(
    topicFactory: Factory<ReadonlyTopic<TMessage>> | ReadonlyTopic<TMessage>,
    listener: Listener<TMessage>,
  ) {
    const topic =
      typeof topicFactory === "function" ? this.use(topicFactory) : topicFactory
    topic.on(this, listener)
  }

  /**
   * Like {@link ReadonlyTopic.once} but will automatically manage disposing the subscription when the current actor is disposed.
   *
   * @param topic - Reference to the topic, i.e. the message factory function.
   * @param listener - A function that will be called every time a message is emitted on the topic.
   */
  once<TMessage>(
    topicFactory: Factory<ReadonlyTopic<TMessage>> | ReadonlyTopic<TMessage>,
    listener: Listener<TMessage>,
  ) {
    const topic =
      typeof topicFactory === "function" ? this.use(topicFactory) : topicFactory
    topic.once(this, listener)
  }

  /**
   * Create a JS interval that will be automatically cancelled when the current actor is disposed.
   */
  interval(
    callback: () => Promisable<void>,
    intervalInMilliseconds?: number | undefined,
  ) {
    if (this.isDisposed) return

    const interval = setInterval(() => {
      try {
        const result = callback()

        if (
          isObject(result) &&
          "catch" in result &&
          typeof result["catch"] === "function"
        ) {
          result["catch"]((error: unknown) => {
            console.error("error in async interval callback", {
              actor: this.name,
              path: this.path,
              error,
            })
          })
        }
      } catch (error) {
        console.error("error in interval callback", {
          actor: this.name,
          path: this.path,
          error,
        })
      }
    }, intervalInMilliseconds)
    this.onCleanup(() => clearInterval(interval))
  }

  /**
   * Create a JS timeout that will be automatically cancelled when the current actor is disposed.
   */
  timeout(
    callback: () => Promisable<void>,
    delayInMilliseconds?: number | undefined,
  ): void {
    if (this.isDisposed) return

    const timer = setTimeout(() => {
      try {
        const result = callback()

        if (
          isObject(result) &&
          "catch" in result &&
          typeof result["catch"] === "function"
        ) {
          result["catch"]((error: unknown) => {
            console.error("error in async timeout callback", {
              actor: this.name,
              path: this.path,
              error,
            })
          })
        }
      } catch (error) {
        console.error("error in timeout callback", {
          actor: this.name,
          path: this.path,
          error,
        })
      }
    }, delayInMilliseconds)
    this.onCleanup(() => clearTimeout(timer))
  }

  /**
   * Fetch a context value.
   *
   * @remarks
   *
   * If the value is not found, it will be instantiated by calling the factory function.
   *
   * @param factory - Factory function corresponding to the desired value.
   * @returns - Return value of the factory function.
   */
  use<TReturn>(factory: Factory<TReturn>, options?: UseOptions | undefined) {
    return this.reactor.use(factory, options)
  }

  /**
   * Instantiate an actor as a child of the current actor.
   *
   * @remarks
   *
   * This is essentially a shorthand for `sig.use(actorFactory).run(sig.reactor, sig)`. If there are any properties passed, the actor will be instantiated statelessly, i.e. it will not be added to the context and can't be accessed via `sig.use`.
   *
   * If you want to create a stateless actor but retain a reference to it, you can use `sig.use(actorFactory, { stateless: true })`.
   *
   * If you want to pass properties to an actor, but still register it in the global context, you can use `sig.use(actorFactory).run(sig, properties)`.
   *
   * In all cases, the actor will inherit the current actor's lifecycle, i.e. it will be disposed when the current actor is disposed.
   *
   * @param factory - Factory function of the actor to be instantiated.
   * @returns - Return value of the first invocation of the actor.
   */
  run<TReturn>(
    factory: Factory<Actor<TReturn>>,
    options?: RunOptions | undefined,
  ): TReturn | undefined {
    return this.reactor.use(factory).run(this.reactor, this, {
      pathPrefix: `${this.path}.`,
      ...options,
    })
  }

  /**
   * Run a map of actors.
   *
   * @remarks
   *
   * The mapped types allows you to specify a map of actors, where the keys are arbitrary strings and the values are actors. The actors will be instantiated as children of the current actor, and will automatically be created and disposed as map items are added or removed.
   * @param factory - Factory function of the mapped actors.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  runMap<TReturn>(
    factory: Factory<Mapped<unknown, Actor<TReturn>>>,
  ): (TReturn | undefined)[] {
    const mapped = this.use(factory)
    const results: (TReturn | undefined)[] = Array.from({ length: mapped.size })

    const runOptions: RunOptions = {
      pathPrefix: `${this.path}.`,
      overrideName: `${mapped[FactoryNameSymbol] ?? "anonymous"}[]`,
    }

    let index = 0
    for (const [, actor, mapLifecycle] of mapped) {
      const actorLifecycle = new DisposableLifecycleScopeImplementation("")
      actorLifecycle.confineTo(mapLifecycle)
      actorLifecycle.confineTo(this)
      results[index++] = actor.run(this.reactor, actorLifecycle, runOptions)
    }

    mapped.additions.on(this, ([, actor, mapLifecycle]) => {
      const actorLifecycle = new DisposableLifecycleScopeImplementation("")
      actorLifecycle.confineTo(mapLifecycle)
      actorLifecycle.confineTo(this)
      actor.run(this.reactor, actorLifecycle, runOptions)
    })

    return results
  }

  /**
   * Run a map of actors sequentially.
   *
   * @remarks
   *
   * This method is similar to `runMap`, but it will wait for each actor to finish starting up before starting the next one. When all actors are started, the method returns.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async runMapSequential<TReturn>(
    factory: Factory<Mapped<unknown, Actor<TReturn>>>,
  ): Promise<(TReturn | undefined)[]> {
    const mapped = this.use(factory)
    const results: (TReturn | undefined)[] = Array.from({ length: mapped.size })

    let index = 0
    for (const [, actor, mapLifecycle] of mapped) {
      const actorLifecycle = new DisposableLifecycleScopeImplementation("")
      actorLifecycle.confineTo(mapLifecycle)
      actorLifecycle.confineTo(this)
      // eslint-disable-next-line @typescript-eslint/await-thenable
      results[index++] = await actor.run(this.reactor, actorLifecycle)
    }

    mapped.additions.on(this, ([, actor, mapLifecycle]) => {
      const actorLifecycle = new DisposableLifecycleScopeImplementation("")
      actorLifecycle.confineTo(mapLifecycle)
      actorLifecycle.confineTo(this)
      actor.run(this.reactor, actorLifecycle)
    })

    return results
  }
}
